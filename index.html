<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PDF Viewer</title>
  <style>
    :root { --bg:#0e0e0f; --fg:#e8e8ea; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); }
    .viewer, iframe { position:fixed; inset:0; width:100%; height:100%; border:0; background:var(--bg); }
    body { overscroll-behavior:none; }

    /* Mobile renderer */
    #mobile-root { position:fixed; inset:0; overflow-y:auto; -webkit-overflow-scrolling:touch; padding:12px 0 56px; display:none; }
    #pages { display:flex; flex-direction:column; align-items:center; gap:12px; transform-origin: top center; }
    canvas { display:block; box-shadow:0 2px 24px rgba(0,0,0,.35); border-radius:6px; background:#111; }
    #loading { position:fixed; top:12px; left:50%; transform:translateX(-50%); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; opacity:.9; }
    #fallback { display:none; position:absolute; inset:0; place-items:center; }
    a { color:#9cf; }

    /* Floating zoom controls */
    #controls { position:fixed; right:12px; bottom:12px; display:flex; flex-direction:column; gap:8px; }
    .btn {
      background:#1a1a1d; color:#fff; border:none; border-radius:10px; width:44px; height:44px;
      font:600 20px/44px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      text-align:center; box-shadow:0 6px 20px rgba(0,0,0,.35); cursor:pointer; user-select:none;
    }
    .btn:active { transform: translateY(1px); }
    #zoomLabel {
      position:fixed; left:12px; bottom:18px; font:12px/1 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:rgba(20,20,22,.75); padding:6px 8px; border-radius:8px;
    }
  </style>
</head>
<body>
  <!-- Desktop: native inline PDF -->
  <iframe id="desktop-frame" class="viewer" src="https://Cam-Choi.github.io/pdf-lander/document.pdf" title="PDF"></iframe>

  <!-- Mobile: scroll-only, zoomable, crisp (re-renders on zoom) -->
  <div id="mobile-root" aria-live="polite">
    <div id="loading">Loading PDF…</div>
    <div id="pages"></div>
    <div id="fallback"><p>Unable to display. <a href="https://Cam-Choi.github.io/pdf-lander/document.pdf">Open the file</a>.</p></div>

    <div id="controls">
      <button id="zoomIn"  class="btn" aria-label="Zoom in">＋</button>
      <button id="zoomOut" class="btn" aria-label="Zoom out">－</button>
      <button id="zoomFit" class="btn" aria-label="Fit to width" title="Fit to width">⤧</button>
    </div>
    <div id="zoomLabel">100%</div>
  </div>

  <script>
    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    const PDF_URL  = "https://Cam-Choi.github.io/pdf-lander/document.pdf";

    if (!isMobile) {
      document.getElementById('desktop-frame').style.display = 'block';
    } else {
      document.getElementById('desktop-frame').style.display = 'none';
      document.getElementById('mobile-root').style.display = 'block';

      const s = document.createElement('script');
      s.src = "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js";
      s.onload = startMobileViewer;
      s.onerror = () => document.getElementById('fallback').style.display = 'grid';
      document.head.appendChild(s);
    }

    function startMobileViewer() {
      const pdfjsLib = window.pdfjsLib;
      if (!pdfjsLib) { document.getElementById('fallback').style.display = 'grid'; return; }

      const pagesEl = document.getElementById('pages');
      const loading = document.getElementById('loading');
      const zoomLabel = document.getElementById('zoomLabel');

      // Persistent state
      let pdfDoc = null;
      let baseFitScale = 1;    // scale that fits width at DPR=1
      let zoom = 1;            // user zoom multiplier (1 = fit width)
      const DPR_CAP = 3;       // cap DPR to avoid memory blowups
      const DPR = Math.min(window.devicePixelRatio || 1, DPR_CAP);

      // Load PDF (worker disabled to avoid extra file)
      const opts = { url: PDF_URL, disableWorker: true };

      pdfjsLib.getDocument(opts).promise.then(async (pdf) => {
        pdfDoc = pdf;
        await fitToWidth();   // sets baseFitScale & renders
        bindUI();
      }).catch(err => {
        console.error(err); loading.remove(); document.getElementById('fallback').style.display = 'grid';
      });

      async function renderAll() {
        // Clear previous canvases
        pagesEl.innerHTML = "";
        loading.textContent = "Rendering…";

        const total = pdfDoc.numPages;
        for (let p = 1; p <= total; p++) {
          loading.textContent = `Rendering ${p}/${total}…`;
          const page = await pdfDoc.getPage(p);

          // target CSS width (minus padding), compute scale
          const cssWidth = Math.min(document.documentElement.clientWidth, window.innerWidth) - 16;
          const unscaled = page.getViewport({ scale: 1 });
          // base scale that would fit to width at DPR=1:
          baseFitScale = cssWidth / unscaled.width;
          // Effective render scale: fit * zoom * DPR
          const renderScale = baseFitScale * zoom * DPR;
          const viewport = page.getViewport({ scale: renderScale });

          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d', { alpha: false });

          canvas.width  = Math.floor(viewport.width);
          canvas.height = Math.floor(viewport.height);
          // show at logical (CSS) size so it fits the screen
          canvas.style.width  = Math.floor(viewport.width  / DPR) + 'px';
          canvas.style.height = Math.floor(viewport.height / DPR) + 'px';

          pagesEl.appendChild(canvas);
          await page.render({ canvasContext: ctx, viewport }).promise;
        }
        loading.remove();
        updateZoomLabel();
      }

      async function fitToWidth() {
        zoom = 1;
        await renderAll();
      }

      function updateZoomLabel() {
        zoomLabel.textContent = Math.round(zoom * 100) + "%";
      }

      // -------- Zoom Controls (buttons) --------
      function clampZoom(z) { return Math.max(0.5, Math.min(z, 4)); } // 50%..400%
      async function zoomIn()  { zoom = clampZoom(zoom * 1.2); await renderAll(); }
      async function zoomOut() { zoom = clampZoom(zoom / 1.2); await renderAll(); }
      async function zoomFit() { await fitToWidth(); }

      function bindUI() {
        document.getElementById('zoomIn').addEventListener('click',  zoomIn);
        document.getElementById('zoomOut').addEventListener('click', zoomOut);
        document.getElementById('zoomFit').addEventListener('click', zoomFit);

        // Double-tap to zoom in
        let lastTap = 0;
        pagesEl.addEventListener('touchend', async (e) => {
          const now = Date.now();
          if (now - lastTap < 300) { // double-tap
            zoom = clampZoom(zoom * 1.5);
            loading.textContent = "Rendering…";
            document.body.appendChild(loading);
            await renderAll();
          }
          lastTap = now;
        });

        // Pinch: preview via CSS scale, re-render on release
        const active = new Map();
        pagesEl.addEventListener('pointerdown', (e) => { active.set(e.pointerId, e); pagesEl.setPointerCapture(e.pointerId); });
        pagesEl.addEventListener('pointermove', (e) => {
          if (!active.has(e.pointerId)) return;
          active.set(e.pointerId, e);
          if (active.size === 2) {
            const [a, b] = [...active.values()];
            const d0 = Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
            if (!pagesEl._pinchStartDist) pagesEl._pinchStartDist = d0, pagesEl._pinchStartZoom = zoom;
            const scalePreview = clampZoom(pagesEl._pinchStartZoom * (d0 / pagesEl._pinchStartDist));
            pagesEl.style.transform = `scale(${scalePreview})`;
          }
        });
        const endPinch = async (e) => {
          if (active.has(e.pointerId)) active.delete(e.pointerId);
          if (active.size < 2 && pagesEl._pinchStartDist) {
            // Commit zoom from the last preview transform
            const m = /scale\\(([^)]+)\\)/.exec(pagesEl.style.transform || "");
            if (m) zoom = clampZoom(parseFloat(m[1]));
            pagesEl.style.transform = "";
            pagesEl._pinchStartDist = null;
            loading.textContent = "Rendering…";
            document.body.appendChild(loading);
            await renderAll();
          }
        };
        pagesEl.addEventListener('pointerup', endPinch);
        pagesEl.addEventListener('pointercancel', endPinch);

        // Re-render on rotate / resize to keep fit-to-width consistent
        let resizeTO;
        window.addEventListener('resize', () => {
          clearTimeout(resizeTO);
          resizeTO = setTimeout(() => { renderAll(); }, 250);
        });
      }
    }
  </script>
</body>
</html>
