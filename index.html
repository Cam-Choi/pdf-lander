<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PDF Viewer</title>
    <style>
      :root { --bg: #0e0e0f; --fg: #e8e8ea; }
      html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); }
      .viewer, iframe { position: fixed; inset: 0; width: 100%; height: 100%; border: 0; background: var(--bg); }
      body { overscroll-behavior: none; }

      /* Mobile scroll renderer */
      #mobile-root { position: fixed; inset: 0; overflow-y: auto; -webkit-overflow-scrolling: touch; padding: 12px 0 48px; display: none; }
      #pages { display: flex; flex-direction: column; align-items: center; gap: 12px; }
      canvas { box-shadow: 0 2px 24px rgba(0,0,0,.35); border-radius: 6px; background: #111; display: block; }
      #loading { position: fixed; top: 12px; left: 50%; transform: translateX(-50%); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; opacity: .85; }
      #fallback { display:none; position: absolute; inset: 0; place-items: center; }
      a { color: #9cf; }
    </style>
  </head>
  <body>
    <!-- Desktop: native inline PDF -->
    <iframe id="desktop-frame" class="viewer" src="https://Cam-Choi.github.io/pdf-lander/document.pdf" title="PDF"></iframe>

    <!-- Mobile: scroll-only renderer (DPR-aware) -->
    <div id="mobile-root" aria-live="polite">
      <div id="loading">Loading PDF…</div>
      <div id="pages"></div>
      <div id="fallback">
        <p>Unable to display the PDF. <a href="https://Cam-Choi.github.io/pdf-lander/document.pdf">Open the file</a>.</p>
      </div>
    </div>

    <script>
      const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      const PDF_URL = "https://Cam-Choi.github.io/pdf-lander/document.pdf";

      if (!isMobile) {
        // Desktop uses built-in viewer
        document.getElementById('desktop-frame').style.display = 'block';
      } else {
        // Mobile: PDF.js (CDN) + high-DPI rendering
        document.getElementById('desktop-frame').style.display = 'none';
        document.getElementById('mobile-root').style.display = 'block';

        const script = document.createElement('script');
        script.src = "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js";
        script.onload = startMobileRenderer;
        script.onerror = () => document.getElementById('fallback').style.display = 'grid';
        document.head.appendChild(script);
      }

      function startMobileRenderer() {
        const pdfjsLib = window.pdfjsLib;
        if (!pdfjsLib) { document.getElementById('fallback').style.display = 'grid'; return; }

        // Simpler reliability: avoid separate worker file
        const getDocOpts = { url: PDF_URL, disableWorker: true };

        const pagesContainer = document.getElementById('pages');
        const loading = document.getElementById('loading');
        const DPR = Math.min(window.devicePixelRatio || 1, 2.5); // cap to avoid huge memory

        pdfjsLib.getDocument(getDocOpts).promise.then(async (pdf) => {
          const total = pdf.numPages;
          if (!total) throw new Error('Empty PDF');

          for (let p = 1; p <= total; p++) {
            loading.textContent = `Rendering ${p}/${total}…`;
            const page = await pdf.getPage(p);

            // Calculate base scale to fit CSS width, then multiply by DPR for crispness
            const unscaled = page.getViewport({ scale: 1 });
            const cssTargetWidth = Math.min(document.documentElement.clientWidth, window.innerWidth) - 16; // side padding
            const baseScale = Math.max(0.1, cssTargetWidth / unscaled.width);
            const renderScale = baseScale * DPR;

            const viewport = page.getViewport({ scale: renderScale });

            // Canvas pixel size = high DPI; CSS size = logical width/height (divide by DPR)
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { alpha: false });

            canvas.width  = Math.floor(viewport.width);
            canvas.height = Math.floor(viewport.height);
            canvas.style.width  = Math.floor(viewport.width  / DPR) + 'px';
            canvas.style.height = Math.floor(viewport.height / DPR) + 'px';

            // Optional: improve perceived sharpness on some browsers
            if (typeof ctx.imageSmoothingEnabled === 'boolean') ctx.imageSmoothingEnabled = true;

            pagesContainer.appendChild(canvas);
            await page.render({ canvasContext: ctx, viewport }).promise;
          }

          loading.remove();
        }).catch((err) => {
          console.error(err);
          loading.remove();
          document.getElementById('fallback').style.display = 'grid';
        });
      }
    </script>
  </body>
</html>
